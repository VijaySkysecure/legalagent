"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.traceStartCreateRun = traceStartCreateRun;
exports.traceStartCreateThreadAndRun = traceStartCreateThreadAndRun;
exports.traceEndCreateOrUpdateRun = traceEndCreateOrUpdateRun;
exports.traceStartSubmitToolOutputsToRun = traceStartSubmitToolOutputsToRun;
exports.traceEndSubmitToolOutputsToRun = traceEndSubmitToolOutputsToRun;
const tracing_js_1 = require("../tracing.js");
const traceUtility_js_1 = require("./traceUtility.js");
function traceStartCreateRun(span, options, threadId, operationName = tracing_js_1.TracingOperationName.CREATE_RUN) {
    var _a, _b, _c, _d, _e, _f, _g;
    const attributes = {
        threadId: threadId,
        agentId: options.body.assistant_id,
        model: (_a = options.body.model) !== null && _a !== void 0 ? _a : undefined,
        instructions: (_b = options.body.instructions) !== null && _b !== void 0 ? _b : undefined,
        temperature: (_c = options.body.temperature) !== null && _c !== void 0 ? _c : undefined,
        topP: (_d = options.body.top_p) !== null && _d !== void 0 ? _d : undefined,
        maxCompletionTokens: (_e = options.body.max_completion_tokens) !== null && _e !== void 0 ? _e : undefined,
        maxPromptTokens: (_f = options.body.max_prompt_tokens) !== null && _f !== void 0 ? _f : undefined,
        responseFormat: (0, traceUtility_js_1.formatAgentApiResponse)(options.body.response_format),
    };
    if (options.body.additional_instructions) {
        attributes.additional_instructions =
            (_g = options.body.additional_instructions) !== null && _g !== void 0 ? _g : undefined;
    }
    tracing_js_1.TracingUtility.setSpanAttributes(span, operationName, (0, traceUtility_js_1.UpdateWithAgentAttributes)(attributes));
    setSpanEvents(span, options);
}
function traceStartCreateThreadAndRun(span, options) {
    traceStartCreateRun(span, options, undefined, tracing_js_1.TracingOperationName.CREATE_THREAD_RUN);
}
async function traceEndCreateOrUpdateRun(span, _options, result) {
    const resolvedResult = await result;
    updateSpanAttributesForRun(span, resolvedResult);
}
function traceStartSubmitToolOutputsToRun(span, options, threadId, runId) {
    const attributes = { threadId: threadId, runId: runId };
    tracing_js_1.TracingUtility.setSpanAttributes(span, tracing_js_1.TracingOperationName.SUBMIT_TOOL_OUTPUTS, (0, traceUtility_js_1.UpdateWithAgentAttributes)(attributes));
    (0, traceUtility_js_1.addToolMessagesEvent)(span, options.body.tool_outputs);
}
async function traceEndSubmitToolOutputsToRun(span, _options, result) {
    const resolvedResult = await result;
    updateSpanAttributesForRun(span, resolvedResult);
}
function updateSpanAttributesForRun(span, output) {
    tracing_js_1.TracingUtility.updateSpanAttributes(span, {
        runId: output.id,
        runStatus: output.status,
        responseModel: output.model,
    });
    const usage = output.usage;
    if (usage && "completion_tokens" in usage && usage.completion_tokens) {
        tracing_js_1.TracingUtility.updateSpanAttributes(span, {
            usageCompletionTokens: usage.completion_tokens,
            usagePromptTokens: usage.prompt_tokens,
        });
    }
}
function setSpanEvents(span, options) {
    var _a;
    (0, traceUtility_js_1.addInstructionsEvent)(span, Object.assign(Object.assign({}, options.body), { agentId: options.body.assistant_id }));
    (_a = options.body.additional_messages) === null || _a === void 0 ? void 0 : _a.forEach((message) => {
        (0, traceUtility_js_1.addMessageEvent)(span, message);
    });
}
//# sourceMappingURL=runTrace.js.map