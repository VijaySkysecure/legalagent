"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRunStreaming = createRunStreaming;
exports.createThreadAndRunStreaming = createThreadAndRunStreaming;
exports.submitToolOutputsToRunStreaming = submitToolOutputsToRunStreaming;
const tslib_1 = require("tslib");
const streamingModels_js_1 = require("./streamingModels.js");
const core_sse_1 = require("@azure/core-sse");
const core_util_1 = require("@azure/core-util");
const inputValidations_js_1 = require("./inputValidations.js");
const openAIError_js_1 = require("./openAIError.js");
const convertOutputModelsFromWire_js_1 = require("../customization/convertOutputModelsFromWire.js");
const logger_js_1 = require("../logger.js");
const expectedStatuses = ["200"];
const handlers = [
    { events: Object.values(streamingModels_js_1.ThreadStreamEvent), converter: convertOutputModelsFromWire_js_1.convertAgentThreadOutput },
    { events: Object.values(streamingModels_js_1.RunStreamEvent), converter: convertOutputModelsFromWire_js_1.convertThreadRunOutput },
    { events: Object.values(streamingModels_js_1.RunStepStreamEvent), converter: convertOutputModelsFromWire_js_1.convertRunStepOutput },
    { events: Object.values(streamingModels_js_1.MessageStreamEvent), converter: convertOutputModelsFromWire_js_1.convertThreadMessageOutput },
];
function createAgentStream(stream) {
    const asyncIterator = toAsyncIterable(stream);
    const asyncDisposable = stream;
    return Object.assign(asyncIterator, asyncDisposable);
}
function toAsyncIterable(stream) {
    return tslib_1.__asyncGenerator(this, arguments, function* toAsyncIterable_1() {
        var _a, e_1, _b, _c;
        try {
            for (var _d = true, stream_1 = tslib_1.__asyncValues(stream), stream_1_1; stream_1_1 = yield tslib_1.__await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true) {
                _c = stream_1_1.value;
                _d = false;
                const event = _c;
                const data = deserializeEventData(event);
                yield yield tslib_1.__await({ data: data, event: event.event });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = stream_1.return)) yield tslib_1.__await(_b.call(stream_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
function deserializeEventData(event) {
    try {
        const jsonData = JSON.parse(event.data);
        switch (event.event) {
            case streamingModels_js_1.MessageStreamEvent.ThreadMessageDelta:
                return (0, convertOutputModelsFromWire_js_1.convertMessageDeltaChunkOutput)(jsonData);
            case streamingModels_js_1.RunStepStreamEvent.ThreadRunStepDelta:
                return (0, convertOutputModelsFromWire_js_1.convertRunStepDeltaChunk)(jsonData);
            default: {
                for (const { events, converter } of handlers) {
                    if (events.includes(event.event)) {
                        return converter(jsonData);
                    }
                }
                return jsonData;
            }
        }
    }
    catch (ex) {
        logger_js_1.logger.error(`Failed to parse event data  ${event.event} - error: ${ex}`);
        return event.data;
    }
}
async function processStream(streamResponse) {
    const result = core_util_1.isNodeLike
        ? await streamResponse.asNodeStream()
        : await streamResponse.asBrowserStream();
    if (!expectedStatuses.includes(result.status)) {
        throw (0, openAIError_js_1.createOpenAIError)(result);
    }
    if (!result.body) {
        throw new Error("No body in response");
    }
    const stream = core_util_1.isNodeLike
        ? (0, core_sse_1.createSseStream)(result.body)
        : (0, core_sse_1.createSseStream)(result.body);
    return createAgentStream(stream);
}
/** Create a run and stream the events */
async function createRunStreaming(context, threadId, options) {
    (0, inputValidations_js_1.validateThreadId)(threadId);
    validateCreateThreadAndRunBodyParam(options);
    options.body.stream = true;
    return processStream(context.path("/threads/{threadId}/runs", threadId).post(options));
}
/** Create a thread and run and stream the events */
async function createThreadAndRunStreaming(context, options) {
    validateCreateThreadAndRunBodyParam(options);
    options.body.stream = true;
    return processStream(context.path("/threads/runs").post(options));
}
async function submitToolOutputsToRunStreaming(context, threadId, runId, options) {
    (0, inputValidations_js_1.validateThreadId)(threadId);
    (0, inputValidations_js_1.validateRunId)(runId);
    options.body.stream = true;
    return processStream(context
        .path("/threads/{threadId}/runs/{runId}/submit_tool_outputs", threadId, runId)
        .post(options));
}
function validateCreateThreadAndRunBodyParam(options) {
    var _a, _b, _c;
    if ("additional_messages" in options.body && options.body.additional_messages) {
        options.body.additional_messages.forEach((message) => (0, inputValidations_js_1.validateMessages)(message.role));
    }
    if ("thread" in options.body && ((_a = options.body.thread) === null || _a === void 0 ? void 0 : _a.messages)) {
        (_b = options.body.thread) === null || _b === void 0 ? void 0 : _b.messages.forEach((message) => (0, inputValidations_js_1.validateMessages)(message.role));
    }
    if (options.body.tools) {
        (0, inputValidations_js_1.validateTools)(options.body.tools);
    }
    if ("tool_resources" in options.body && (options === null || options === void 0 ? void 0 : options.body.tool_resources)) {
        (0, inputValidations_js_1.validateToolResources)(options.body.tool_resources);
    }
    if (options.body.temperature && (options.body.temperature < 0 || options.body.temperature > 2)) {
        throw new Error("Temperature must be between 0 and 2");
    }
    if (options.body.tool_choice && typeof options.body.tool_choice !== "string") {
        (0, inputValidations_js_1.validateTools)([options.body.tool_choice]);
    }
    if ((_c = options.body.truncation_strategy) === null || _c === void 0 ? void 0 : _c.type) {
        (0, inputValidations_js_1.validateTruncationStrategy)(options.body.truncation_strategy.type);
    }
    if (options.body.response_format) {
        if (!["json", "text"].includes(options.body.response_format)) {
            throw new Error("Response format must be either 'json' or 'text'");
        }
    }
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        (0, inputValidations_js_1.validateMetadata)(options.body.metadata);
    }
}
//# sourceMappingURL=streaming.js.map