"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.traceStartAgentGeneric = traceStartAgentGeneric;
exports.traceEndAgentGeneric = traceEndAgentGeneric;
exports.UpdateWithAgentAttributes = UpdateWithAgentAttributes;
exports.addMessageEvent = addMessageEvent;
exports.addInstructionsEvent = addInstructionsEvent;
exports.formatAgentApiResponse = formatAgentApiResponse;
exports.addToolMessagesEvent = addToolMessagesEvent;
const tracing_js_1 = require("../tracing.js");
const telemetry_js_1 = require("../telemetry/telemetry.js");
function traceStartAgentGeneric(span, options) {
    var _a;
    const attributeOptions = options.tracingAttributeOptions || {};
    tracing_js_1.TracingUtility.setSpanAttributes(span, ((_a = options.tracingAttributeOptions) === null || _a === void 0 ? void 0 : _a.operationName) || "Agent_Operation", UpdateWithAgentAttributes(attributeOptions));
}
function traceEndAgentGeneric(span, _options) {
    const attributeOptions = {};
    tracing_js_1.TracingUtility.updateSpanAttributes(span, UpdateWithAgentAttributes(attributeOptions));
}
function UpdateWithAgentAttributes(attributeOptions) {
    attributeOptions.genAiSystem = tracing_js_1.TracingAttributes.AZ_AI_AGENT_SYSTEM;
    return attributeOptions;
}
/**
 * Adds a message event to the span.
 * @param span - The span to add the event to.
 * @param messageAttributes - The attributes of the message event.
 */
function addMessageEvent(span, messageAttributes, usage) {
    var _a;
    const eventBody = {};
    const telemetryOptions = (0, telemetry_js_1.getTelemetryOptions)();
    if (telemetryOptions.enableContentRecording) {
        eventBody.content = getMessageContent(messageAttributes.content);
    }
    eventBody.role = messageAttributes.role;
    if (messageAttributes.attachments) {
        eventBody.attachments = messageAttributes.attachments.map((attachment) => {
            return {
                id: attachment.file_id,
                tools: attachment.tools.map((tool) => tool.type),
            };
        });
    }
    const threadId = messageAttributes.thread_id;
    const agentId = (_a = messageAttributes.assistant_id) !== null && _a !== void 0 ? _a : undefined;
    const threadRunId = messageAttributes.run_id;
    const messageStatus = messageAttributes.status;
    const messageId = messageAttributes.id;
    const incompleteDetails = messageAttributes.incomplete_details;
    if (incompleteDetails) {
        eventBody.incomplete_details = incompleteDetails;
    }
    const usagePromptTokens = usage === null || usage === void 0 ? void 0 : usage.prompt_tokens;
    const usageCompletionTokens = usage === null || usage === void 0 ? void 0 : usage.completion_tokens;
    const attributes = {
        eventContent: JSON.stringify(eventBody),
        threadId,
        agentId,
        threadRunId,
        messageStatus,
        messageId,
        usagePromptTokens,
        usageCompletionTokens,
        genAiSystem: tracing_js_1.TracingAttributes.AZ_AI_AGENT_SYSTEM,
    };
    tracing_js_1.TracingUtility.addSpanEvent(span, `gen_ai.${messageAttributes.role}.message`, attributes);
}
/**
 * Adds an instruction event to the span.
 * @param span - The span to add the event to.
 * @param instructionAttributes - The attributes of the instruction event.
 */
function addInstructionsEvent(span, instructionAttributes) {
    const eventBody = {};
    if (instructionAttributes.instructions || instructionAttributes.additional_instructions) {
        eventBody.content =
            instructionAttributes.instructions && instructionAttributes.additional_instructions
                ? `${instructionAttributes.instructions} ${instructionAttributes.additional_instructions}`
                : instructionAttributes.instructions || instructionAttributes.additional_instructions;
    }
    const attributes = {
        eventContent: JSON.stringify(eventBody),
        threadId: instructionAttributes.threadId,
        agentId: instructionAttributes.agentId,
        genAiSystem: tracing_js_1.TracingAttributes.AZ_AI_AGENT_SYSTEM,
    };
    tracing_js_1.TracingUtility.addSpanEvent(span, "gen_ai.system.message", attributes);
}
/**
 * Formats the agent API response.
 * @param responseFormat - The response format option.
 * @returns The formatted response as a string, or null/undefined.
 */
function formatAgentApiResponse(responseFormat) {
    var _a;
    if (typeof responseFormat === "string" ||
        responseFormat === undefined ||
        responseFormat === null) {
        return responseFormat !== null && responseFormat !== void 0 ? responseFormat : undefined;
    }
    if (responseFormat.type) {
        return (_a = responseFormat.type) !== null && _a !== void 0 ? _a : undefined;
    }
    return undefined;
}
/**
 * Adds a tool messages event to the span
 * @param span - The span to add the event to.
 * @param tool_outputs - List of tool oupts
 */
function addToolMessagesEvent(span, tool_outputs) {
    tool_outputs.forEach((tool_output) => {
        const eventBody = { content: tool_output.output, id: tool_output.tool_call_id };
        tracing_js_1.TracingUtility.addSpanEvent(span, "gen_ai.tool.message", {
            eventContent: JSON.stringify(eventBody),
            genAiSystem: tracing_js_1.TracingAttributes.AZ_AI_AGENT_SYSTEM,
        });
    });
}
function getMessageContent(messageContent) {
    if (!Array.isArray(messageContent)) {
        return messageContent;
    }
    const contentBody = {};
    messageContent.forEach((content) => {
        const typedContent = content.type;
        const { value, annotations } = content[typedContent];
        contentBody[typedContent] = { value, annotations };
    });
    return contentBody;
}
//# sourceMappingURL=traceUtility.js.map