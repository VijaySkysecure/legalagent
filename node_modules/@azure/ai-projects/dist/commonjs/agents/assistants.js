"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAgent = createAgent;
exports.listAgents = listAgents;
exports.getAgent = getAgent;
exports.updateAgent = updateAgent;
exports.deleteAgent = deleteAgent;
const tslib_1 = require("tslib");
const core_client_1 = require("@azure-rest/core-client");
const inputValidations_js_1 = require("./inputValidations.js");
const tracing_js_1 = require("../tracing.js");
const assistantsTrace_js_1 = require("./assistantsTrace.js");
const traceUtility_js_1 = require("./traceUtility.js");
const ConvertFromWire = tslib_1.__importStar(require("../customization/convertOutputModelsFromWire.js"));
const ConverterToWire = tslib_1.__importStar(require("../customization/convertModelsToWrite.js"));
const convertParametersToWire_js_1 = require("../customization/convertParametersToWire.js");
const openAIError_js_1 = require("./openAIError.js");
const expectedStatuses = ["200"];
var Tools;
(function (Tools) {
    Tools["CodeInterpreter"] = "code_interpreter";
    Tools["FileSearch"] = "file_search";
    Tools["Function"] = "function";
    Tools["BingGrounding"] = "bing_grounding";
    Tools["MicrosoftFabric"] = "fabric_dataagent";
    Tools["SharepointGrounding"] = "sharepoint_grounding";
    Tools["AzureAISearch"] = "azure_ai_search";
    Tools["OpenApi"] = "openapi";
    Tools["AzureFunction"] = "azure_function";
})(Tools || (Tools = {}));
/** Creates a new agent. */
async function createAgent(context, model, options = {}) {
    const createOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: Object.assign({}, ConverterToWire.convertCreateAgentOptions(Object.assign(Object.assign({}, options), { model }))) });
    validateCreateAgentParameters(createOptions);
    const response = await tracing_js_1.TracingUtility.withSpan("CreateAgent", createOptions, async (updatedOptions) => {
        const result = await context.path("/assistants").post(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, assistantsTrace_js_1.traceStartCreateOrUpdateAgent, assistantsTrace_js_1.traceEndCreateOrUpdateAgent);
    return ConvertFromWire.convertAgentOutput(response);
}
/** Gets a list of agents that were previously created. */
async function listAgents(context, options = {}) {
    const listAgentsOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { queryParameters: (0, convertParametersToWire_js_1.convertToListQueryParameters)(options) });
    validateListAgentsParameters(listAgentsOptions);
    const response = await tracing_js_1.TracingUtility.withSpan("ListAgents", listAgentsOptions || {}, async (updateOptions) => {
        const result = await context.path("/assistants").get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    });
    return ConvertFromWire.convertOpenAIPageableListOfAgentOutput(response);
}
/** Retrieves an existing agent. */
async function getAgent(context, assistantId, options = {}) {
    const getAgentOptions = Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options));
    validateAssistantId(assistantId);
    const response = await tracing_js_1.TracingUtility.withSpan("GetAgent", getAgentOptions, async (updateOptions) => {
        const result = await context
            .path("/assistants/{assistantId}", assistantId)
            .get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, (span, updatedOptions) => (0, traceUtility_js_1.traceStartAgentGeneric)(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { agentId: assistantId } })));
    return ConvertFromWire.convertAgentOutput(response);
}
/** Modifies an existing agent. */
async function updateAgent(context, assistantId, options = {}) {
    const updateAgentOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: Object.assign({}, ConverterToWire.convertUpdateAgentOptions(options)) });
    validateUpdateAgentParameters(assistantId, updateAgentOptions);
    const response = await tracing_js_1.TracingUtility.withSpan("UpdateAgent", updateAgentOptions, async (updateOptions) => {
        const result = await context
            .path("/assistants/{assistantId}", assistantId)
            .post(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, (span, updatedOptions) => (0, assistantsTrace_js_1.traceStartCreateOrUpdateAgent)(span, updatedOptions, assistantId), assistantsTrace_js_1.traceEndCreateOrUpdateAgent);
    return ConvertFromWire.convertAgentOutput(response);
}
/** Deletes an agent. */
async function deleteAgent(context, assistantId, options = {}) {
    const deleteAgentOptions = Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options));
    validateAssistantId(assistantId);
    const response = await tracing_js_1.TracingUtility.withSpan("DeleteAgent", deleteAgentOptions, async (updateOptions) => {
        const result = await context
            .path("/assistants/{assistantId}", assistantId)
            .delete(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, traceUtility_js_1.traceStartAgentGeneric, traceUtility_js_1.traceEndAgentGeneric);
    return ConvertFromWire.convertAgentDeletionStatusOutput(response);
}
function validateCreateAgentParameters(options) {
    var _a;
    if (options.body.tools) {
        if (options.body.tools.some((value) => !Object.values(Tools).includes(value.type))) {
            throw new Error("Tool type must be one of 'code_interpreter', 'file_search', 'function', 'bing_grounding', 'fabric_dataagent', 'sharepoint_grounding', 'azure_ai_search', 'azure_function'");
        }
    }
    if (options.body.tool_resources) {
        if (options.body.tool_resources.code_interpreter) {
            if (options.body.tool_resources.code_interpreter.file_ids &&
                options.body.tool_resources.code_interpreter.data_sources) {
                throw new Error("Only file_ids or data_sources can be provided, not both");
            }
            if (options.body.tool_resources.code_interpreter.file_ids &&
                options.body.tool_resources.code_interpreter.file_ids.length > 20) {
                throw new Error("A maximum of 20 file IDs are allowed");
            }
            if (options.body.tool_resources.code_interpreter.data_sources) {
                (0, inputValidations_js_1.validateVectorStoreDataType)(options.body.tool_resources.code_interpreter.data_sources);
            }
        }
        if (options.body.tool_resources.file_search) {
            if (options.body.tool_resources.file_search.vector_store_ids &&
                options.body.tool_resources.file_search.vector_store_ids.length > 1) {
                throw new Error("Only one vector store ID is allowed");
            }
            if (options.body.tool_resources.file_search.vector_stores) {
                if (options.body.tool_resources.file_search.vector_stores.length > 1) {
                    throw new Error("Only one vector store is allowed");
                }
                (0, inputValidations_js_1.validateVectorStoreDataType)((_a = options.body.tool_resources.file_search.vector_stores[0]) === null || _a === void 0 ? void 0 : _a.configuration.data_sources);
            }
        }
        if (options.body.tool_resources.azure_ai_search) {
            if (options.body.tool_resources.azure_ai_search.indexes &&
                options.body.tool_resources.azure_ai_search.indexes.length > 1) {
                throw new Error("Only one index is allowed");
            }
        }
    }
    if (options.body.temperature && (options.body.temperature < 0 || options.body.temperature > 2)) {
        throw new Error("Temperature must be between 0 and 2");
    }
    if (options.body.metadata) {
        (0, inputValidations_js_1.validateMetadata)(options.body.metadata);
    }
}
function validateListAgentsParameters(options) {
    var _a, _b;
    if ((_a = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _a === void 0 ? void 0 : _a.limit) {
        (0, inputValidations_js_1.validateLimit)(options.queryParameters.limit);
    }
    if ((_b = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _b === void 0 ? void 0 : _b.order) {
        (0, inputValidations_js_1.validateOrder)(options.queryParameters.order);
    }
}
function validateAssistantId(assistantId) {
    if (!assistantId) {
        throw new Error("Assistant ID is required");
    }
}
function validateUpdateAgentParameters(assistantId, options) {
    validateAssistantId(assistantId);
    if (options) {
        validateCreateAgentParameters(options);
    }
}
//# sourceMappingURL=assistants.js.map