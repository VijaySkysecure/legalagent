"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createThread = createThread;
exports.getThread = getThread;
exports.updateThread = updateThread;
exports.deleteThread = deleteThread;
const tslib_1 = require("tslib");
const core_client_1 = require("@azure-rest/core-client");
const ConverterToWire = tslib_1.__importStar(require("../customization/convertModelsToWrite.js"));
const ConverterFromWire = tslib_1.__importStar(require("../customization/convertOutputModelsFromWire.js"));
const tracing_js_1 = require("../tracing.js");
const threadsTrace_js_1 = require("./threadsTrace.js");
const inputValidations_js_1 = require("./inputValidations.js");
const traceUtility_js_1 = require("./traceUtility.js");
const convertOutputModelsFromWire_js_1 = require("../customization/convertOutputModelsFromWire.js");
const openAIError_js_1 = require("./openAIError.js");
const expectedStatuses = ["200"];
/** Creates a new thread. Threads contain messages and can be run by agents. */
async function createThread(context, options = {}) {
    const createThreadOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: Object.assign({}, ConverterToWire.convertAgentThreadCreationOptions(options)) });
    validateCreateThreadParameters(createThreadOptions);
    const response = await tracing_js_1.TracingUtility.withSpan("CreateThread", createThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads").post(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, threadsTrace_js_1.traceStartCreateThread, threadsTrace_js_1.traceEndCreateThread);
    return ConverterFromWire.convertAgentThreadOutput(response);
}
/** Gets information about an existing thread. */
async function getThread(context, threadId, options = {}) {
    const getThreadOptions = Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options));
    (0, inputValidations_js_1.validateThreadId)(threadId);
    const response = await tracing_js_1.TracingUtility.withSpan("GetThread", getThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads/{threadId}", threadId).get(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, (span, updatedOptions) => (0, traceUtility_js_1.traceStartAgentGeneric)(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
    return ConverterFromWire.convertAgentThreadOutput(response);
}
/** Modifies an existing thread. */
async function updateThread(context, threadId, options = {}) {
    const updateThreadOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: Object.assign({}, ConverterToWire.convertAgentThreadUpdateOptions(options)) });
    validateUpdateThreadParameters(threadId, updateThreadOptions);
    const response = await tracing_js_1.TracingUtility.withSpan("UpdateThread", updateThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads/{threadId}", threadId).post(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, (span, updatedOptions) => (0, traceUtility_js_1.traceStartAgentGeneric)(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
    return ConverterFromWire.convertAgentThreadOutput(response);
}
/** Deletes an existing thread. */
async function deleteThread(context, threadId, options = {}) {
    const deleteThreadOptions = Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options));
    (0, inputValidations_js_1.validateThreadId)(threadId);
    const response = await tracing_js_1.TracingUtility.withSpan("DeleteThread", deleteThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads/{threadId}", threadId).delete(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, (span, updatedOptions) => (0, traceUtility_js_1.traceStartAgentGeneric)(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
    return (0, convertOutputModelsFromWire_js_1.convertThreadDeletionStatusOutput)(response);
}
function validateCreateThreadParameters(options) {
    if (options === null || options === void 0 ? void 0 : options.body.messages) {
        options.body.messages.forEach((message) => (0, inputValidations_js_1.validateMessages)(message.role));
    }
    if (options === null || options === void 0 ? void 0 : options.body.tool_resources) {
        (0, inputValidations_js_1.validateToolResources)(options.body.tool_resources);
    }
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        (0, inputValidations_js_1.validateMetadata)(options.body.metadata);
    }
}
function validateUpdateThreadParameters(threadId, options) {
    (0, inputValidations_js_1.validateThreadId)(threadId);
    if (options === null || options === void 0 ? void 0 : options.body.tool_resources) {
        (0, inputValidations_js_1.validateToolResources)(options.body.tool_resources);
    }
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        (0, inputValidations_js_1.validateMetadata)(options.body.metadata);
    }
}
//# sourceMappingURL=threads.js.map