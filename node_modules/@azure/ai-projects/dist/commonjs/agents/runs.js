"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRun = createRun;
exports.listRuns = listRuns;
exports.getRun = getRun;
exports.updateRun = updateRun;
exports.submitToolOutputsToRun = submitToolOutputsToRun;
exports.cancelRun = cancelRun;
exports.createThreadAndRun = createThreadAndRun;
const tslib_1 = require("tslib");
const core_client_1 = require("@azure-rest/core-client");
const inputValidations_js_1 = require("./inputValidations.js");
const tracing_js_1 = require("../tracing.js");
const runTrace_js_1 = require("./runTrace.js");
const traceUtility_js_1 = require("./traceUtility.js");
const streaming_js_1 = require("./streaming.js");
const ConverterToWire = tslib_1.__importStar(require("../customization/convertModelsToWrite.js"));
const ConvertFromWire = tslib_1.__importStar(require("../customization/convertOutputModelsFromWire.js"));
const convertParametersToWire_js_1 = require("../customization/convertParametersToWire.js");
const openAIError_js_1 = require("./openAIError.js");
const expectedStatuses = ["200"];
/** Creates and starts a new run of the specified thread using the specified agent. */
function createRun(context, threadId, assistantId, options) {
    const createRunOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: Object.assign(Object.assign({}, ConverterToWire.convertCreateRunOptions(Object.assign(Object.assign({}, options), { assistantId }))), { stream: false }) });
    (0, inputValidations_js_1.validateThreadId)(threadId);
    validateCreateRunParameters(createRunOptions);
    async function executeCreateRun() {
        const output = await tracing_js_1.TracingUtility.withSpan("CreateRun", createRunOptions, async (updateOptions) => {
            const result = await context.path("/threads/{threadId}/runs", threadId).post(updateOptions);
            if (!expectedStatuses.includes(result.status)) {
                const error = (0, openAIError_js_1.createOpenAIError)(result);
                throw error;
            }
            return result.body;
        }, (span, updatedOptions) => (0, runTrace_js_1.traceStartCreateRun)(span, updatedOptions, threadId), runTrace_js_1.traceEndCreateOrUpdateRun);
        return ConvertFromWire.convertThreadRunOutput(output);
    }
    return {
        then: function (onFulfilled, onRejected) {
            return executeCreateRun().then(onFulfilled, onRejected).catch(onRejected);
        },
        async stream() {
            return (0, streaming_js_1.createRunStreaming)(context, threadId, createRunOptions);
        },
    };
}
/** Gets a list of runs for a specified thread. */
async function listRuns(context, threadId, options = {}) {
    const listRunOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { queryParameters: (0, convertParametersToWire_js_1.convertToListQueryParameters)(options) });
    validateListRunsParameters(threadId, options);
    return tracing_js_1.TracingUtility.withSpan("ListRuns", listRunOptions || {}, async (updateOptions) => {
        const result = await context.path("/threads/{threadId}/runs", threadId).get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return ConvertFromWire.convertOpenAIPageableListOfThreadRunOutput(result.body);
    }, (span, updatedOptions) => (0, traceUtility_js_1.traceStartAgentGeneric)(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
}
/** Gets an existing run from an existing thread. */
async function getRun(context, threadId, runId, options = {}) {
    (0, inputValidations_js_1.validateThreadId)(threadId);
    (0, inputValidations_js_1.validateRunId)(runId);
    const getRunOptions = Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options));
    return tracing_js_1.TracingUtility.withSpan("GetRun", getRunOptions, async (updateOptions) => {
        const result = await context
            .path("/threads/{threadId}/runs/{runId}", threadId, runId)
            .get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return ConvertFromWire.convertThreadRunOutput(result.body);
    }, (span, updatedOptions) => (0, traceUtility_js_1.traceStartAgentGeneric)(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId, runId: runId } })));
}
/** Modifies an existing thread run. */
async function updateRun(context, threadId, runId, options = {}) {
    const updateRunOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: {
            metadata: options === null || options === void 0 ? void 0 : options.metadata,
        } });
    validateUpdateRunParameters(threadId, runId, updateRunOptions);
    const response = await tracing_js_1.TracingUtility.withSpan("UpdateRun", updateRunOptions, async (updateOptions) => {
        const result = await context
            .path("/threads/{threadId}/runs/{runId}", threadId, runId)
            .post(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return result.body;
    }, (span, updatedOptions) => (0, traceUtility_js_1.traceStartAgentGeneric)(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId, runId: runId } })), runTrace_js_1.traceEndCreateOrUpdateRun);
    return ConvertFromWire.convertThreadRunOutput(response);
}
/** Submits outputs from tools as requested by tool calls in a run. Runs that need submitted tool outputs will have a status of 'requires_action' with a required_action.type of 'submit_tool_outputs'. */
function submitToolOutputsToRun(context, threadId, runId, toolOutputs, options = {}) {
    (0, inputValidations_js_1.validateThreadId)(threadId);
    (0, inputValidations_js_1.validateRunId)(runId);
    const submitToolOutputsOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: {
            tool_outputs: toolOutputs === null || toolOutputs === void 0 ? void 0 : toolOutputs.map(ConverterToWire.convertToolOutput),
            stream: false,
        } });
    async function executeSubmitToolOutputsToRun() {
        const response = await tracing_js_1.TracingUtility.withSpan("SubmitToolOutputsToRun", submitToolOutputsOptions, async (updateOptions) => {
            const result = await context
                .path("/threads/{threadId}/runs/{runId}/submit_tool_outputs", threadId, runId)
                .post(updateOptions);
            if (!expectedStatuses.includes(result.status)) {
                throw (0, openAIError_js_1.createOpenAIError)(result);
            }
            return result.body;
        }, (span, updatedOptions) => (0, runTrace_js_1.traceStartSubmitToolOutputsToRun)(span, updatedOptions, threadId, runId), runTrace_js_1.traceEndSubmitToolOutputsToRun);
        return ConvertFromWire.convertThreadRunOutput(response);
    }
    return {
        then: function (onFulfilled, onrejected) {
            return executeSubmitToolOutputsToRun().then(onFulfilled, onrejected).catch(onrejected);
        },
        async stream() {
            return (0, streaming_js_1.submitToolOutputsToRunStreaming)(context, threadId, runId, submitToolOutputsOptions);
        },
    };
}
/** Cancels a run of an in progress thread. */
async function cancelRun(context, threadId, runId, options = {}) {
    (0, inputValidations_js_1.validateThreadId)(threadId);
    (0, inputValidations_js_1.validateRunId)(runId);
    const cancelRunOptions = Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options));
    return tracing_js_1.TracingUtility.withSpan("CancelRun", cancelRunOptions, async (updateOptions) => {
        const result = await context
            .path("/threads/{threadId}/runs/{runId}/cancel", threadId, runId)
            .post(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw (0, openAIError_js_1.createOpenAIError)(result);
        }
        return ConvertFromWire.convertThreadRunOutput(result.body);
    });
}
/** Creates a new thread and immediately starts a run of that thread. */
function createThreadAndRun(context, assistantId, options) {
    const createThreadAndRunOptions = Object.assign(Object.assign({}, (0, core_client_1.operationOptionsToRequestParameters)(options)), { body: Object.assign(Object.assign({}, ConverterToWire.convertCreateAndRunThreadOptions(Object.assign(Object.assign({}, options), { assistantId }))), { stream: false }) });
    validateCreateThreadAndRunParameters(createThreadAndRunOptions);
    async function executeCreateThreadAndRun() {
        const response = await tracing_js_1.TracingUtility.withSpan("CreateThreadAndRun", createThreadAndRunOptions, async (updateOptions) => {
            const result = await context.path("/threads/runs").post(updateOptions);
            if (!expectedStatuses.includes(result.status)) {
                throw (0, openAIError_js_1.createOpenAIError)(result);
            }
            return result.body;
        }, runTrace_js_1.traceStartCreateThreadAndRun, runTrace_js_1.traceEndCreateOrUpdateRun);
        return ConvertFromWire.convertThreadRunOutput(response);
    }
    return {
        then: function (onFulfilled, onrejected) {
            return executeCreateThreadAndRun().then(onFulfilled, onrejected).catch(onrejected);
        },
        async stream() {
            return (0, streaming_js_1.createThreadAndRunStreaming)(context, createThreadAndRunOptions);
        },
    };
}
function validateListRunsParameters(thread_id, options) {
    var _a, _b, _c;
    (0, inputValidations_js_1.validateThreadId)(thread_id);
    if (((_a = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _a === void 0 ? void 0 : _a.limit) &&
        (options.queryParameters.limit < 1 || options.queryParameters.limit > 100)) {
        throw new Error("Limit must be between 1 and 100");
    }
    if ((_b = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _b === void 0 ? void 0 : _b.limit) {
        (0, inputValidations_js_1.validateLimit)(options.queryParameters.limit);
    }
    if ((_c = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _c === void 0 ? void 0 : _c.order) {
        (0, inputValidations_js_1.validateOrder)(options.queryParameters.order);
    }
}
function validateUpdateRunParameters(thread_id, run_id, options) {
    (0, inputValidations_js_1.validateThreadId)(thread_id);
    (0, inputValidations_js_1.validateRunId)(run_id);
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        (0, inputValidations_js_1.validateMetadata)(options.body.metadata);
    }
}
function validateCreateRunParameters(options) {
    var _a;
    if ("additional_messages" in options.body && options.body.additional_messages) {
        options.body.additional_messages.forEach((message) => (0, inputValidations_js_1.validateMessages)(message.role));
    }
    if (options.body.tools) {
        (0, inputValidations_js_1.validateTools)(options.body.tools);
    }
    if (options.body.temperature && (options.body.temperature < 0 || options.body.temperature > 2)) {
        throw new Error("Temperature must be between 0 and 2");
    }
    if (options.body.tool_choice && typeof options.body.tool_choice !== "string") {
        (0, inputValidations_js_1.validateTools)([options.body.tool_choice]);
    }
    if ((_a = options.body.truncation_strategy) === null || _a === void 0 ? void 0 : _a.type) {
        (0, inputValidations_js_1.validateTruncationStrategy)(options.body.truncation_strategy.type);
    }
    if (options.body.metadata) {
        (0, inputValidations_js_1.validateMetadata)(options.body.metadata);
    }
}
function validateCreateThreadAndRunParameters(options) {
    var _a, _b, _c;
    validateCreateRunParameters(options);
    if ((_a = options.body.thread) === null || _a === void 0 ? void 0 : _a.messages) {
        (_b = options.body.thread) === null || _b === void 0 ? void 0 : _b.messages.forEach((message) => (0, inputValidations_js_1.validateMessages)(message.role));
    }
    if (options.body.tools) {
        (0, inputValidations_js_1.validateTools)(options.body.tools);
    }
    if ((_c = options.body.tool_resources) === null || _c === void 0 ? void 0 : _c.code_interpreter) {
        if (options.body.tool_resources.code_interpreter) {
            if (options.body.tool_resources.code_interpreter.file_ids &&
                options.body.tool_resources.code_interpreter.file_ids.length > 20) {
                throw new Error("A maximum of 20 file IDs are allowed");
            }
        }
        if (options.body.tool_resources.file_search) {
            if (options.body.tool_resources.file_search.vector_store_ids &&
                options.body.tool_resources.file_search.vector_store_ids.length > 1) {
                throw new Error("Only one vector store ID is allowed");
            }
        }
        if (options.body.tool_resources.azure_ai_search) {
            if (options.body.tool_resources.azure_ai_search.indexes &&
                options.body.tool_resources.azure_ai_search.indexes.length > 1) {
                throw new Error("Only one index is allowed");
            }
        }
    }
}
//# sourceMappingURL=runs.js.map