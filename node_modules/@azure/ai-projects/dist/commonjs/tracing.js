"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TracingUtility = exports.TracingOperationName = exports.TracingAttributes = void 0;
const core_tracing_1 = require("@azure/core-tracing");
const constants_js_1 = require("./constants.js");
const core_util_1 = require("@azure/core-util");
const logger_js_1 = require("./logger.js");
var TracingAttributes;
(function (TracingAttributes) {
    TracingAttributes["GEN_AI_MESSAGE_ID"] = "gen_ai.message.id";
    TracingAttributes["GEN_AI_MESSAGE_STATUS"] = "gen_ai.message.status";
    TracingAttributes["GEN_AI_THREAD_ID"] = "gen_ai.thread.id";
    TracingAttributes["GEN_AI_THREAD_RUN_ID"] = "gen_ai.thread.run.id";
    TracingAttributes["GEN_AI_AGENT_ID"] = "gen_ai.agent.id";
    TracingAttributes["GEN_AI_AGENT_NAME"] = "gen_ai.agent.name";
    TracingAttributes["GEN_AI_AGENT_DESCRIPTION"] = "gen_ai.agent.description";
    TracingAttributes["GEN_AI_OPERATION_NAME"] = "gen_ai.operation.name";
    TracingAttributes["GEN_AI_THREAD_RUN_STATUS"] = "gen_ai.thread.run.status";
    TracingAttributes["GEN_AI_REQUEST_MODEL"] = "gen_ai.request.model";
    TracingAttributes["GEN_AI_REQUEST_TEMPERATURE"] = "gen_ai.request.temperature";
    TracingAttributes["GEN_AI_REQUEST_TOP_P"] = "gen_ai.request.top_p";
    TracingAttributes["GEN_AI_REQUEST_MAX_INPUT_TOKENS"] = "gen_ai.request.max_input_tokens";
    TracingAttributes["GEN_AI_REQUEST_MAX_OUTPUT_TOKENS"] = "gen_ai.request.max_output_tokens";
    TracingAttributes["GEN_AI_RESPONSE_MODEL"] = "gen_ai.response.model";
    TracingAttributes["GEN_AI_SYSTEM"] = "gen_ai.system";
    TracingAttributes["SERVER_ADDRESS"] = "server.address";
    TracingAttributes["AZ_AI_AGENT_SYSTEM"] = "az.ai.agents";
    TracingAttributes["GEN_AI_TOOL_NAME"] = "gen_ai.tool.name";
    TracingAttributes["GEN_AI_TOOL_CALL_ID"] = "gen_ai.tool.call.id";
    TracingAttributes["GEN_AI_REQUEST_RESPONSE_FORMAT"] = "gen_ai.request.response_format";
    TracingAttributes["GEN_AI_USAGE_INPUT_TOKENS"] = "gen_ai.usage.input_tokens";
    TracingAttributes["GEN_AI_USAGE_OUTPUT_TOKENS"] = "gen_ai.usage.output_tokens";
    TracingAttributes["GEN_AI_SYSTEM_MESSAGE"] = "gen_ai.system.message";
    TracingAttributes["GEN_AI_EVENT_CONTENT"] = "gen_ai.event.content";
    TracingAttributes["ERROR_TYPE"] = "error.type";
})(TracingAttributes || (exports.TracingAttributes = TracingAttributes = {}));
var TracingOperationName;
(function (TracingOperationName) {
    TracingOperationName["CREATE_AGENT"] = "create_agent";
    TracingOperationName["CREATE_UPDATE_AGENT"] = "update_agent";
    TracingOperationName["CREATE_THREAD"] = "create_thread";
    TracingOperationName["CREATE_MESSAGE"] = "create_message";
    TracingOperationName["CREATE_RUN"] = "create_run";
    TracingOperationName["START_THREAD_RUN"] = "start_thread_run";
    TracingOperationName["EXECUTE_TOOL"] = "execute_tool";
    TracingOperationName["LIST_MESSAGES"] = "list_messages";
    TracingOperationName["SUBMIT_TOOL_OUTPUTS"] = "submit_tool_outputs";
    TracingOperationName["CREATE_THREAD_RUN"] = "create_thread_run";
})(TracingOperationName || (exports.TracingOperationName = TracingOperationName = {}));
class TracingUtility {
    static async withSpan(name, options, request, startTrace, endTrace) {
        return TracingUtility.tracingClient.withSpan(name, options, async (updatedOptions, span) => {
            if (startTrace) {
                try {
                    updatedOptions.tracingAttributeOptions = Object.assign(Object.assign({}, updatedOptions.tracingAttributeOptions), { operationName: name });
                    startTrace(span, updatedOptions);
                }
                catch (e) {
                    logger_js_1.logger.warning(`Skipping updating span before request execution due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
                }
            }
            let result;
            try {
                result = await request(updatedOptions);
            }
            catch (error) {
                const errorStatus = { status: "error" };
                if (error instanceof Error) {
                    errorStatus.error = error;
                }
                throw error;
            }
            if (endTrace && result !== undefined) {
                try {
                    endTrace(span, updatedOptions, result);
                }
                catch (e) {
                    logger_js_1.logger.warning(`Skipping updating span after request execution due to an error: ${(0, core_util_1.getErrorMessage)(e)}`);
                }
            }
            return result;
        }, { spanKind: "client" });
    }
    static updateSpanAttributes(span, attributeOptions) {
        TracingUtility.setAttributes(span, attributeOptions);
    }
    static setSpanAttributes(span, operationName, attributeOptions) {
        attributeOptions.operationName = operationName;
        TracingUtility.setAttributes(span, attributeOptions);
    }
    static setAttributes(span, attributeOptions) {
        if (span.isRecording()) {
            const { name, operationName, description, serverAddress, threadId, agentId, messageId, runId, model, temperature, topP, maxPromptTokens, maxCompletionTokens, responseFormat, runStatus, responseModel, usageCompletionTokens, usagePromptTokens, genAiSystem = TracingAttributes.AZ_AI_AGENT_SYSTEM, } = attributeOptions;
            if (genAiSystem) {
                span.setAttribute(TracingAttributes.GEN_AI_SYSTEM, genAiSystem);
            }
            if (name) {
                span.setAttribute(TracingAttributes.GEN_AI_AGENT_NAME, name);
            }
            if (description) {
                span.setAttribute(TracingAttributes.GEN_AI_AGENT_DESCRIPTION, description);
            }
            if (serverAddress) {
                span.setAttribute(TracingAttributes.SERVER_ADDRESS, serverAddress);
            }
            if (threadId) {
                span.setAttribute(TracingAttributes.GEN_AI_THREAD_ID, threadId);
            }
            if (agentId) {
                span.setAttribute(TracingAttributes.GEN_AI_AGENT_ID, agentId);
            }
            if (runId) {
                span.setAttribute(TracingAttributes.GEN_AI_THREAD_RUN_ID, runId);
            }
            if (messageId) {
                span.setAttribute(TracingAttributes.GEN_AI_MESSAGE_ID, messageId);
            }
            if (model) {
                span.setAttribute(TracingAttributes.GEN_AI_REQUEST_MODEL, model);
            }
            if (temperature !== null) {
                span.setAttribute(TracingAttributes.GEN_AI_REQUEST_TEMPERATURE, temperature);
            }
            if (topP !== null) {
                span.setAttribute(TracingAttributes.GEN_AI_REQUEST_TOP_P, topP);
            }
            if (maxPromptTokens !== null) {
                span.setAttribute(TracingAttributes.GEN_AI_REQUEST_MAX_INPUT_TOKENS, maxPromptTokens);
            }
            if (maxCompletionTokens !== null) {
                span.setAttribute(TracingAttributes.GEN_AI_REQUEST_MAX_OUTPUT_TOKENS, maxCompletionTokens);
            }
            if (responseFormat) {
                span.setAttribute(TracingAttributes.GEN_AI_REQUEST_RESPONSE_FORMAT, responseFormat);
            }
            if (runStatus) {
                span.setAttribute(TracingAttributes.GEN_AI_THREAD_RUN_STATUS, runStatus);
            }
            if (responseModel) {
                span.setAttribute(TracingAttributes.GEN_AI_RESPONSE_MODEL, responseModel);
            }
            if (usagePromptTokens) {
                span.setAttribute(TracingAttributes.GEN_AI_USAGE_INPUT_TOKENS, usagePromptTokens);
            }
            if (usageCompletionTokens) {
                span.setAttribute(TracingAttributes.GEN_AI_USAGE_OUTPUT_TOKENS, usageCompletionTokens);
            }
            if (operationName) {
                span.setAttribute(TracingAttributes.GEN_AI_OPERATION_NAME, operationName);
            }
        }
        return;
    }
    static addSpanEvent(span, eventName, attributeOptions) {
        if (span.isRecording()) {
            const { threadId, agentId, runId, messageId, eventContent, usageCompletionTokens, usagePromptTokens, messageStatus, } = attributeOptions;
            const attributes = {};
            if (eventContent) {
                attributes[TracingAttributes.GEN_AI_EVENT_CONTENT] = eventContent;
            }
            if (threadId) {
                attributes[TracingAttributes.GEN_AI_THREAD_ID] = threadId;
            }
            if (agentId) {
                attributes[TracingAttributes.GEN_AI_AGENT_ID] = agentId;
            }
            if (runId) {
                attributes[TracingAttributes.GEN_AI_THREAD_RUN_ID] = runId;
            }
            if (messageId) {
                attributes[TracingAttributes.GEN_AI_MESSAGE_ID] = messageId;
            }
            if (messageStatus) {
                attributes[TracingAttributes.GEN_AI_MESSAGE_STATUS] = messageStatus;
            }
            if (usagePromptTokens) {
                attributes[TracingAttributes.GEN_AI_USAGE_INPUT_TOKENS] = usagePromptTokens;
            }
            if (usageCompletionTokens) {
                attributes[TracingAttributes.GEN_AI_USAGE_OUTPUT_TOKENS] = usageCompletionTokens;
            }
            if (span.addEvent) {
                span.addEvent(eventName, { attributes });
            }
        }
        return;
    }
}
exports.TracingUtility = TracingUtility;
TracingUtility.tracingClient = (0, core_tracing_1.createTracingClient)({
    namespace: "Microsoft.CognitiveServices",
    packageName: constants_js_1.PACKAGE_NAME,
    packageVersion: constants_js_1.SDK_VERSION,
});
//# sourceMappingURL=tracing.js.map