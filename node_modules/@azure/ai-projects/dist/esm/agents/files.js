// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { operationOptionsToRequestParameters } from "@azure-rest/core-client";
import { createPoller } from "./poller.js";
import * as ConvertFromWire from "../customization/convertOutputModelsFromWire.js";
import * as ConvertParameters from "../customization/convertParametersToWire.js";
import { randomUUID } from "@azure/core-util";
import { createOpenAIError } from "./openAIError.js";
const expectedStatuses = ["200"];
var FilePurpose;
(function (FilePurpose) {
    FilePurpose["FineTune"] = "fine-tune";
    FilePurpose["FineTuneResults"] = "fine-tune-results";
    FilePurpose["Assistants"] = "assistants";
    FilePurpose["AssistantsOutput"] = "assistants_output";
    FilePurpose["Batch"] = "batch";
    FilePurpose["BatchOutput"] = "batch_output";
    FilePurpose["Vision"] = "vision";
})(FilePurpose || (FilePurpose = {}));
/** Gets a list of previously uploaded files. */
export async function listFiles(context, options = {}) {
    const listOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: ConvertParameters.convertListFilesQueryParamProperties(options) });
    validateListFilesParameters(listOptions);
    const result = await context.path("/files").get(options);
    if (!expectedStatuses.includes(result.status)) {
        throw createOpenAIError(result);
    }
    return ConvertFromWire.convertFileListResponseOutput(result.body);
}
/** Uploads a file for use by other operations. */
export function uploadFile(context, content, purpose, options = {}) {
    var _a;
    return createPoller({
        initOperation: async () => {
            return uploadFileInternal(context, content, purpose, options);
        },
        pollOperation: async (currentResult) => {
            return getFile(context, currentResult.id, options);
        },
        getOperationStatus: getLroOperationStatus,
        getOperationError: (result) => {
            return result.status === "failed" && result.statusDetails
                ? new Error(`Operation failed: ${result.statusDetails}`)
                : undefined;
        },
        intervalInMs: (_a = options.pollingOptions) === null || _a === void 0 ? void 0 : _a.sleepIntervalInMs,
    });
}
export function uploadFileAndPoll(context, content, purpose, options = {}) {
    var _a;
    return createPoller({
        initOperation: async () => {
            return uploadFileInternal(context, content, purpose, options);
        },
        pollOperation: async (currentResult) => {
            return getFile(context, currentResult.id, options);
        },
        getOperationStatus: getLroOperationStatus,
        getOperationError: (result) => {
            return result.status === "failed" && result.statusDetails
                ? new Error(`Operation failed: ${result.statusDetails}`)
                : undefined;
        },
        intervalInMs: (_a = options.pollingOptions) === null || _a === void 0 ? void 0 : _a.sleepIntervalInMs,
    });
}
/** Delete a previously uploaded file. */
export async function deleteFile(context, fileId, options = {}) {
    const deleteOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    validateFileId(fileId);
    const result = await context.path("/files/{fileId}", fileId).delete(deleteOptions);
    if (!expectedStatuses.includes(result.status)) {
        throw createOpenAIError(result);
    }
    return result.body;
}
/** Returns information about a specific file. Does not retrieve file content. */
export async function getFile(context, fileId, options = {}) {
    validateFileId(fileId);
    const getFileOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    const result = await context.path("/files/{fileId}", fileId).get(getFileOptions);
    if (!expectedStatuses.includes(result.status)) {
        throw createOpenAIError(result);
    }
    return ConvertFromWire.convertOpenAIFileOutput(result.body);
}
/** Returns file content. */
export function getFileContent(context, fileId, options = {}) {
    validateFileId(fileId);
    const getFileContentOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    return context.path("/files/{fileId}/content", fileId).get(getFileContentOptions);
}
export async function uploadFileInternal(context, content, purpose, options = {}) {
    var _a;
    const uploadFileOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: [
            { name: "file", body: content, filename: (_a = options.fileName) !== null && _a !== void 0 ? _a : randomUUID() },
            { name: "purpose", body: purpose },
        ], contentType: "multipart/form-data" });
    const result = await context.path("/files").post(uploadFileOptions);
    if (!expectedStatuses.includes(result.status)) {
        throw createOpenAIError(result);
    }
    return ConvertFromWire.convertOpenAIFileOutput(result.body);
}
function getLroOperationStatus(result) {
    switch (result.status) {
        case "running":
        case "pending":
            return "running";
        case "uploaded":
        case "processed":
            return "succeeded";
        default:
            return "failed";
    }
}
function validateListFilesParameters(options) {
    var _a, _b;
    if ((_a = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _a === void 0 ? void 0 : _a.purpose) {
        if (!Object.values(FilePurpose).includes((_b = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _b === void 0 ? void 0 : _b.purpose)) {
            throw new Error("Purpose must be one of 'fine-tune', 'fine-tune-results', 'assistants', 'assistants_output', 'batch', 'batch_output', 'vision'");
        }
    }
}
function validateFileId(fileId) {
    if (!fileId) {
        throw new Error("File ID is required");
    }
}
//# sourceMappingURL=files.js.map