// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { operationOptionsToRequestParameters } from "@azure-rest/core-client";
import * as ConverterToWire from "../customization/convertModelsToWrite.js";
import * as ConverterFromWire from "../customization/convertOutputModelsFromWire.js";
import { TracingUtility } from "../tracing.js";
import { traceEndCreateThread, traceStartCreateThread } from "./threadsTrace.js";
import { validateMessages, validateMetadata, validateThreadId, validateToolResources, } from "./inputValidations.js";
import { traceStartAgentGeneric } from "./traceUtility.js";
import { convertThreadDeletionStatusOutput } from "../customization/convertOutputModelsFromWire.js";
import { createOpenAIError } from "./openAIError.js";
const expectedStatuses = ["200"];
/** Creates a new thread. Threads contain messages and can be run by agents. */
export async function createThread(context, options = {}) {
    const createThreadOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: Object.assign({}, ConverterToWire.convertAgentThreadCreationOptions(options)) });
    validateCreateThreadParameters(createThreadOptions);
    const response = await TracingUtility.withSpan("CreateThread", createThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads").post(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, traceStartCreateThread, traceEndCreateThread);
    return ConverterFromWire.convertAgentThreadOutput(response);
}
/** Gets information about an existing thread. */
export async function getThread(context, threadId, options = {}) {
    const getThreadOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    validateThreadId(threadId);
    const response = await TracingUtility.withSpan("GetThread", getThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads/{threadId}", threadId).get(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, (span, updatedOptions) => traceStartAgentGeneric(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
    return ConverterFromWire.convertAgentThreadOutput(response);
}
/** Modifies an existing thread. */
export async function updateThread(context, threadId, options = {}) {
    const updateThreadOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: Object.assign({}, ConverterToWire.convertAgentThreadUpdateOptions(options)) });
    validateUpdateThreadParameters(threadId, updateThreadOptions);
    const response = await TracingUtility.withSpan("UpdateThread", updateThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads/{threadId}", threadId).post(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, (span, updatedOptions) => traceStartAgentGeneric(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
    return ConverterFromWire.convertAgentThreadOutput(response);
}
/** Deletes an existing thread. */
export async function deleteThread(context, threadId, options = {}) {
    const deleteThreadOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    validateThreadId(threadId);
    const response = await TracingUtility.withSpan("DeleteThread", deleteThreadOptions, async (updatedOptions) => {
        const result = await context.path("/threads/{threadId}", threadId).delete(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, (span, updatedOptions) => traceStartAgentGeneric(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
    return convertThreadDeletionStatusOutput(response);
}
function validateCreateThreadParameters(options) {
    if (options === null || options === void 0 ? void 0 : options.body.messages) {
        options.body.messages.forEach((message) => validateMessages(message.role));
    }
    if (options === null || options === void 0 ? void 0 : options.body.tool_resources) {
        validateToolResources(options.body.tool_resources);
    }
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        validateMetadata(options.body.metadata);
    }
}
function validateUpdateThreadParameters(threadId, options) {
    validateThreadId(threadId);
    if (options === null || options === void 0 ? void 0 : options.body.tool_resources) {
        validateToolResources(options.body.tool_resources);
    }
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        validateMetadata(options.body.metadata);
    }
}
//# sourceMappingURL=threads.js.map