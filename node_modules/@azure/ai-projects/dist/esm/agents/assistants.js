// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { operationOptionsToRequestParameters } from "@azure-rest/core-client";
import { validateLimit, validateMetadata, validateOrder, validateVectorStoreDataType, } from "./inputValidations.js";
import { TracingUtility } from "../tracing.js";
import { traceEndCreateOrUpdateAgent, traceStartCreateOrUpdateAgent } from "./assistantsTrace.js";
import { traceEndAgentGeneric, traceStartAgentGeneric } from "./traceUtility.js";
import * as ConvertFromWire from "../customization/convertOutputModelsFromWire.js";
import * as ConverterToWire from "../customization/convertModelsToWrite.js";
import { convertToListQueryParameters } from "../customization/convertParametersToWire.js";
import { createOpenAIError } from "./openAIError.js";
const expectedStatuses = ["200"];
var Tools;
(function (Tools) {
    Tools["CodeInterpreter"] = "code_interpreter";
    Tools["FileSearch"] = "file_search";
    Tools["Function"] = "function";
    Tools["BingGrounding"] = "bing_grounding";
    Tools["MicrosoftFabric"] = "fabric_dataagent";
    Tools["SharepointGrounding"] = "sharepoint_grounding";
    Tools["AzureAISearch"] = "azure_ai_search";
    Tools["OpenApi"] = "openapi";
    Tools["AzureFunction"] = "azure_function";
})(Tools || (Tools = {}));
/** Creates a new agent. */
export async function createAgent(context, model, options = {}) {
    const createOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: Object.assign({}, ConverterToWire.convertCreateAgentOptions(Object.assign(Object.assign({}, options), { model }))) });
    validateCreateAgentParameters(createOptions);
    const response = await TracingUtility.withSpan("CreateAgent", createOptions, async (updatedOptions) => {
        const result = await context.path("/assistants").post(updatedOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, traceStartCreateOrUpdateAgent, traceEndCreateOrUpdateAgent);
    return ConvertFromWire.convertAgentOutput(response);
}
/** Gets a list of agents that were previously created. */
export async function listAgents(context, options = {}) {
    const listAgentsOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: convertToListQueryParameters(options) });
    validateListAgentsParameters(listAgentsOptions);
    const response = await TracingUtility.withSpan("ListAgents", listAgentsOptions || {}, async (updateOptions) => {
        const result = await context.path("/assistants").get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    });
    return ConvertFromWire.convertOpenAIPageableListOfAgentOutput(response);
}
/** Retrieves an existing agent. */
export async function getAgent(context, assistantId, options = {}) {
    const getAgentOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    validateAssistantId(assistantId);
    const response = await TracingUtility.withSpan("GetAgent", getAgentOptions, async (updateOptions) => {
        const result = await context
            .path("/assistants/{assistantId}", assistantId)
            .get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, (span, updatedOptions) => traceStartAgentGeneric(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { agentId: assistantId } })));
    return ConvertFromWire.convertAgentOutput(response);
}
/** Modifies an existing agent. */
export async function updateAgent(context, assistantId, options = {}) {
    const updateAgentOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: Object.assign({}, ConverterToWire.convertUpdateAgentOptions(options)) });
    validateUpdateAgentParameters(assistantId, updateAgentOptions);
    const response = await TracingUtility.withSpan("UpdateAgent", updateAgentOptions, async (updateOptions) => {
        const result = await context
            .path("/assistants/{assistantId}", assistantId)
            .post(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, (span, updatedOptions) => traceStartCreateOrUpdateAgent(span, updatedOptions, assistantId), traceEndCreateOrUpdateAgent);
    return ConvertFromWire.convertAgentOutput(response);
}
/** Deletes an agent. */
export async function deleteAgent(context, assistantId, options = {}) {
    const deleteAgentOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    validateAssistantId(assistantId);
    const response = await TracingUtility.withSpan("DeleteAgent", deleteAgentOptions, async (updateOptions) => {
        const result = await context
            .path("/assistants/{assistantId}", assistantId)
            .delete(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, traceStartAgentGeneric, traceEndAgentGeneric);
    return ConvertFromWire.convertAgentDeletionStatusOutput(response);
}
function validateCreateAgentParameters(options) {
    var _a;
    if (options.body.tools) {
        if (options.body.tools.some((value) => !Object.values(Tools).includes(value.type))) {
            throw new Error("Tool type must be one of 'code_interpreter', 'file_search', 'function', 'bing_grounding', 'fabric_dataagent', 'sharepoint_grounding', 'azure_ai_search', 'azure_function'");
        }
    }
    if (options.body.tool_resources) {
        if (options.body.tool_resources.code_interpreter) {
            if (options.body.tool_resources.code_interpreter.file_ids &&
                options.body.tool_resources.code_interpreter.data_sources) {
                throw new Error("Only file_ids or data_sources can be provided, not both");
            }
            if (options.body.tool_resources.code_interpreter.file_ids &&
                options.body.tool_resources.code_interpreter.file_ids.length > 20) {
                throw new Error("A maximum of 20 file IDs are allowed");
            }
            if (options.body.tool_resources.code_interpreter.data_sources) {
                validateVectorStoreDataType(options.body.tool_resources.code_interpreter.data_sources);
            }
        }
        if (options.body.tool_resources.file_search) {
            if (options.body.tool_resources.file_search.vector_store_ids &&
                options.body.tool_resources.file_search.vector_store_ids.length > 1) {
                throw new Error("Only one vector store ID is allowed");
            }
            if (options.body.tool_resources.file_search.vector_stores) {
                if (options.body.tool_resources.file_search.vector_stores.length > 1) {
                    throw new Error("Only one vector store is allowed");
                }
                validateVectorStoreDataType((_a = options.body.tool_resources.file_search.vector_stores[0]) === null || _a === void 0 ? void 0 : _a.configuration.data_sources);
            }
        }
        if (options.body.tool_resources.azure_ai_search) {
            if (options.body.tool_resources.azure_ai_search.indexes &&
                options.body.tool_resources.azure_ai_search.indexes.length > 1) {
                throw new Error("Only one index is allowed");
            }
        }
    }
    if (options.body.temperature && (options.body.temperature < 0 || options.body.temperature > 2)) {
        throw new Error("Temperature must be between 0 and 2");
    }
    if (options.body.metadata) {
        validateMetadata(options.body.metadata);
    }
}
function validateListAgentsParameters(options) {
    var _a, _b;
    if ((_a = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _a === void 0 ? void 0 : _a.limit) {
        validateLimit(options.queryParameters.limit);
    }
    if ((_b = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _b === void 0 ? void 0 : _b.order) {
        validateOrder(options.queryParameters.order);
    }
}
function validateAssistantId(assistantId) {
    if (!assistantId) {
        throw new Error("Assistant ID is required");
    }
}
function validateUpdateAgentParameters(assistantId, options) {
    validateAssistantId(assistantId);
    if (options) {
        validateCreateAgentParameters(options);
    }
}
//# sourceMappingURL=assistants.js.map