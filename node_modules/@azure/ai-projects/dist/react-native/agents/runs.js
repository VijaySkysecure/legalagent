// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { operationOptionsToRequestParameters } from "@azure-rest/core-client";
import { validateLimit, validateMessages, validateMetadata, validateOrder, validateRunId, validateThreadId, validateTools, validateTruncationStrategy, } from "./inputValidations.js";
import { TracingUtility } from "../tracing.js";
import { traceEndCreateOrUpdateRun, traceEndSubmitToolOutputsToRun, traceStartCreateRun, traceStartCreateThreadAndRun, traceStartSubmitToolOutputsToRun, } from "./runTrace.js";
import { traceStartAgentGeneric } from "./traceUtility.js";
import { createRunStreaming, createThreadAndRunStreaming, submitToolOutputsToRunStreaming, } from "./streaming.js";
import * as ConverterToWire from "../customization/convertModelsToWrite.js";
import * as ConvertFromWire from "../customization/convertOutputModelsFromWire.js";
import { convertToListQueryParameters } from "../customization/convertParametersToWire.js";
import { createOpenAIError } from "./openAIError.js";
const expectedStatuses = ["200"];
/** Creates and starts a new run of the specified thread using the specified agent. */
export function createRun(context, threadId, assistantId, options) {
    const createRunOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: Object.assign(Object.assign({}, ConverterToWire.convertCreateRunOptions(Object.assign(Object.assign({}, options), { assistantId }))), { stream: false }) });
    validateThreadId(threadId);
    validateCreateRunParameters(createRunOptions);
    async function executeCreateRun() {
        const output = await TracingUtility.withSpan("CreateRun", createRunOptions, async (updateOptions) => {
            const result = await context.path("/threads/{threadId}/runs", threadId).post(updateOptions);
            if (!expectedStatuses.includes(result.status)) {
                const error = createOpenAIError(result);
                throw error;
            }
            return result.body;
        }, (span, updatedOptions) => traceStartCreateRun(span, updatedOptions, threadId), traceEndCreateOrUpdateRun);
        return ConvertFromWire.convertThreadRunOutput(output);
    }
    return {
        then: function (onFulfilled, onRejected) {
            return executeCreateRun().then(onFulfilled, onRejected).catch(onRejected);
        },
        async stream() {
            return createRunStreaming(context, threadId, createRunOptions);
        },
    };
}
/** Gets a list of runs for a specified thread. */
export async function listRuns(context, threadId, options = {}) {
    const listRunOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { queryParameters: convertToListQueryParameters(options) });
    validateListRunsParameters(threadId, options);
    return TracingUtility.withSpan("ListRuns", listRunOptions || {}, async (updateOptions) => {
        const result = await context.path("/threads/{threadId}/runs", threadId).get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return ConvertFromWire.convertOpenAIPageableListOfThreadRunOutput(result.body);
    }, (span, updatedOptions) => traceStartAgentGeneric(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId } })));
}
/** Gets an existing run from an existing thread. */
export async function getRun(context, threadId, runId, options = {}) {
    validateThreadId(threadId);
    validateRunId(runId);
    const getRunOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    return TracingUtility.withSpan("GetRun", getRunOptions, async (updateOptions) => {
        const result = await context
            .path("/threads/{threadId}/runs/{runId}", threadId, runId)
            .get(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return ConvertFromWire.convertThreadRunOutput(result.body);
    }, (span, updatedOptions) => traceStartAgentGeneric(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId, runId: runId } })));
}
/** Modifies an existing thread run. */
export async function updateRun(context, threadId, runId, options = {}) {
    const updateRunOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            metadata: options === null || options === void 0 ? void 0 : options.metadata,
        } });
    validateUpdateRunParameters(threadId, runId, updateRunOptions);
    const response = await TracingUtility.withSpan("UpdateRun", updateRunOptions, async (updateOptions) => {
        const result = await context
            .path("/threads/{threadId}/runs/{runId}", threadId, runId)
            .post(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return result.body;
    }, (span, updatedOptions) => traceStartAgentGeneric(span, Object.assign(Object.assign({}, updatedOptions), { tracingAttributeOptions: { threadId: threadId, runId: runId } })), traceEndCreateOrUpdateRun);
    return ConvertFromWire.convertThreadRunOutput(response);
}
/** Submits outputs from tools as requested by tool calls in a run. Runs that need submitted tool outputs will have a status of 'requires_action' with a required_action.type of 'submit_tool_outputs'. */
export function submitToolOutputsToRun(context, threadId, runId, toolOutputs, options = {}) {
    validateThreadId(threadId);
    validateRunId(runId);
    const submitToolOutputsOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: {
            tool_outputs: toolOutputs === null || toolOutputs === void 0 ? void 0 : toolOutputs.map(ConverterToWire.convertToolOutput),
            stream: false,
        } });
    async function executeSubmitToolOutputsToRun() {
        const response = await TracingUtility.withSpan("SubmitToolOutputsToRun", submitToolOutputsOptions, async (updateOptions) => {
            const result = await context
                .path("/threads/{threadId}/runs/{runId}/submit_tool_outputs", threadId, runId)
                .post(updateOptions);
            if (!expectedStatuses.includes(result.status)) {
                throw createOpenAIError(result);
            }
            return result.body;
        }, (span, updatedOptions) => traceStartSubmitToolOutputsToRun(span, updatedOptions, threadId, runId), traceEndSubmitToolOutputsToRun);
        return ConvertFromWire.convertThreadRunOutput(response);
    }
    return {
        then: function (onFulfilled, onrejected) {
            return executeSubmitToolOutputsToRun().then(onFulfilled, onrejected).catch(onrejected);
        },
        async stream() {
            return submitToolOutputsToRunStreaming(context, threadId, runId, submitToolOutputsOptions);
        },
    };
}
/** Cancels a run of an in progress thread. */
export async function cancelRun(context, threadId, runId, options = {}) {
    validateThreadId(threadId);
    validateRunId(runId);
    const cancelRunOptions = Object.assign({}, operationOptionsToRequestParameters(options));
    return TracingUtility.withSpan("CancelRun", cancelRunOptions, async (updateOptions) => {
        const result = await context
            .path("/threads/{threadId}/runs/{runId}/cancel", threadId, runId)
            .post(updateOptions);
        if (!expectedStatuses.includes(result.status)) {
            throw createOpenAIError(result);
        }
        return ConvertFromWire.convertThreadRunOutput(result.body);
    });
}
/** Creates a new thread and immediately starts a run of that thread. */
export function createThreadAndRun(context, assistantId, options) {
    const createThreadAndRunOptions = Object.assign(Object.assign({}, operationOptionsToRequestParameters(options)), { body: Object.assign(Object.assign({}, ConverterToWire.convertCreateAndRunThreadOptions(Object.assign(Object.assign({}, options), { assistantId }))), { stream: false }) });
    validateCreateThreadAndRunParameters(createThreadAndRunOptions);
    async function executeCreateThreadAndRun() {
        const response = await TracingUtility.withSpan("CreateThreadAndRun", createThreadAndRunOptions, async (updateOptions) => {
            const result = await context.path("/threads/runs").post(updateOptions);
            if (!expectedStatuses.includes(result.status)) {
                throw createOpenAIError(result);
            }
            return result.body;
        }, traceStartCreateThreadAndRun, traceEndCreateOrUpdateRun);
        return ConvertFromWire.convertThreadRunOutput(response);
    }
    return {
        then: function (onFulfilled, onrejected) {
            return executeCreateThreadAndRun().then(onFulfilled, onrejected).catch(onrejected);
        },
        async stream() {
            return createThreadAndRunStreaming(context, createThreadAndRunOptions);
        },
    };
}
function validateListRunsParameters(thread_id, options) {
    var _a, _b, _c;
    validateThreadId(thread_id);
    if (((_a = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _a === void 0 ? void 0 : _a.limit) &&
        (options.queryParameters.limit < 1 || options.queryParameters.limit > 100)) {
        throw new Error("Limit must be between 1 and 100");
    }
    if ((_b = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _b === void 0 ? void 0 : _b.limit) {
        validateLimit(options.queryParameters.limit);
    }
    if ((_c = options === null || options === void 0 ? void 0 : options.queryParameters) === null || _c === void 0 ? void 0 : _c.order) {
        validateOrder(options.queryParameters.order);
    }
}
function validateUpdateRunParameters(thread_id, run_id, options) {
    validateThreadId(thread_id);
    validateRunId(run_id);
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        validateMetadata(options.body.metadata);
    }
}
function validateCreateRunParameters(options) {
    var _a;
    if ("additional_messages" in options.body && options.body.additional_messages) {
        options.body.additional_messages.forEach((message) => validateMessages(message.role));
    }
    if (options.body.tools) {
        validateTools(options.body.tools);
    }
    if (options.body.temperature && (options.body.temperature < 0 || options.body.temperature > 2)) {
        throw new Error("Temperature must be between 0 and 2");
    }
    if (options.body.tool_choice && typeof options.body.tool_choice !== "string") {
        validateTools([options.body.tool_choice]);
    }
    if ((_a = options.body.truncation_strategy) === null || _a === void 0 ? void 0 : _a.type) {
        validateTruncationStrategy(options.body.truncation_strategy.type);
    }
    if (options.body.metadata) {
        validateMetadata(options.body.metadata);
    }
}
function validateCreateThreadAndRunParameters(options) {
    var _a, _b, _c;
    validateCreateRunParameters(options);
    if ((_a = options.body.thread) === null || _a === void 0 ? void 0 : _a.messages) {
        (_b = options.body.thread) === null || _b === void 0 ? void 0 : _b.messages.forEach((message) => validateMessages(message.role));
    }
    if (options.body.tools) {
        validateTools(options.body.tools);
    }
    if ((_c = options.body.tool_resources) === null || _c === void 0 ? void 0 : _c.code_interpreter) {
        if (options.body.tool_resources.code_interpreter) {
            if (options.body.tool_resources.code_interpreter.file_ids &&
                options.body.tool_resources.code_interpreter.file_ids.length > 20) {
                throw new Error("A maximum of 20 file IDs are allowed");
            }
        }
        if (options.body.tool_resources.file_search) {
            if (options.body.tool_resources.file_search.vector_store_ids &&
                options.body.tool_resources.file_search.vector_store_ids.length > 1) {
                throw new Error("Only one vector store ID is allowed");
            }
        }
        if (options.body.tool_resources.azure_ai_search) {
            if (options.body.tool_resources.azure_ai_search.indexes &&
                options.body.tool_resources.azure_ai_search.indexes.length > 1) {
                throw new Error("Only one index is allowed");
            }
        }
    }
}
//# sourceMappingURL=runs.js.map