// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { TracingUtility, TracingOperationName } from "../tracing.js";
import { addInstructionsEvent, addMessageEvent, addToolMessagesEvent, formatAgentApiResponse, UpdateWithAgentAttributes, } from "./traceUtility.js";
export function traceStartCreateRun(span, options, threadId, operationName = TracingOperationName.CREATE_RUN) {
    var _a, _b, _c, _d, _e, _f, _g;
    const attributes = {
        threadId: threadId,
        agentId: options.body.assistant_id,
        model: (_a = options.body.model) !== null && _a !== void 0 ? _a : undefined,
        instructions: (_b = options.body.instructions) !== null && _b !== void 0 ? _b : undefined,
        temperature: (_c = options.body.temperature) !== null && _c !== void 0 ? _c : undefined,
        topP: (_d = options.body.top_p) !== null && _d !== void 0 ? _d : undefined,
        maxCompletionTokens: (_e = options.body.max_completion_tokens) !== null && _e !== void 0 ? _e : undefined,
        maxPromptTokens: (_f = options.body.max_prompt_tokens) !== null && _f !== void 0 ? _f : undefined,
        responseFormat: formatAgentApiResponse(options.body.response_format),
    };
    if (options.body.additional_instructions) {
        attributes.additional_instructions =
            (_g = options.body.additional_instructions) !== null && _g !== void 0 ? _g : undefined;
    }
    TracingUtility.setSpanAttributes(span, operationName, UpdateWithAgentAttributes(attributes));
    setSpanEvents(span, options);
}
export function traceStartCreateThreadAndRun(span, options) {
    traceStartCreateRun(span, options, undefined, TracingOperationName.CREATE_THREAD_RUN);
}
export async function traceEndCreateOrUpdateRun(span, _options, result) {
    const resolvedResult = await result;
    updateSpanAttributesForRun(span, resolvedResult);
}
export function traceStartSubmitToolOutputsToRun(span, options, threadId, runId) {
    const attributes = { threadId: threadId, runId: runId };
    TracingUtility.setSpanAttributes(span, TracingOperationName.SUBMIT_TOOL_OUTPUTS, UpdateWithAgentAttributes(attributes));
    addToolMessagesEvent(span, options.body.tool_outputs);
}
export async function traceEndSubmitToolOutputsToRun(span, _options, result) {
    const resolvedResult = await result;
    updateSpanAttributesForRun(span, resolvedResult);
}
function updateSpanAttributesForRun(span, output) {
    TracingUtility.updateSpanAttributes(span, {
        runId: output.id,
        runStatus: output.status,
        responseModel: output.model,
    });
    const usage = output.usage;
    if (usage && "completion_tokens" in usage && usage.completion_tokens) {
        TracingUtility.updateSpanAttributes(span, {
            usageCompletionTokens: usage.completion_tokens,
            usagePromptTokens: usage.prompt_tokens,
        });
    }
}
function setSpanEvents(span, options) {
    var _a;
    addInstructionsEvent(span, Object.assign(Object.assign({}, options.body), { agentId: options.body.assistant_id }));
    (_a = options.body.additional_messages) === null || _a === void 0 ? void 0 : _a.forEach((message) => {
        addMessageEvent(span, message);
    });
}
//# sourceMappingURL=runTrace.js.map