// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// Conversion functions
export function convertCreateAgentOptions(source) {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ model: source.model }, (source.name && { name: source.name })), (source.description && { description: source.description })), (source.instructions && { instructions: source.instructions })), (source.tools && { tools: source.tools.map(convertToolDefinition) })), (source.toolResources && { tool_resources: convertToolResources(source.toolResources) })), (source.temperature !== undefined && { temperature: source.temperature })), (source.topP !== undefined && { top_p: source.topP })), (source.responseFormat && { response_format: source.responseFormat })), (source.metadata && { metadata: source.metadata }));
}
function convertToolResources(source) {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, (source.codeInterpreter && {
        code_interpreter: convertCodeInterpreterToolResource(source.codeInterpreter),
    })), (source.fileSearch && { file_search: convertFileSearchToolResource(source.fileSearch) })), (source.azureAISearch && {
        azure_ai_search: convertAzureAISearchResource(source.azureAISearch),
    })), (source.azureFunction && {
        name: source.azureFunction.name,
    }));
}
function convertMessageAttachmentToolDefinition(source) {
    switch (source.type) {
        case "code_interpreter":
            return convertCodeInterpreterToolDefinition(source);
        case "file_search":
            return convertFileSearchToolDefinition(source);
        default:
            throw new Error(`Unknown tool type: ${source}`);
    }
}
function convertToolDefinition(source) {
    switch (source.type) {
        case "code_interpreter":
            return convertCodeInterpreterToolDefinition(source);
        case "file_search":
            return convertFileSearchToolDefinition(source);
        case "function":
            return convertFunctionToolDefinition(source);
        case "bing_grounding":
            return convertBingGroundingToolDefinition(source);
        case "fabric_dataagent":
            return convertMicrosoftFabricToolDefinition(source);
        case "sharepoint_grounding":
            return convertSharepointToolDefinition(source);
        case "azure_ai_search":
            return convertAzureAISearchToolDefinition(source);
        case "openapi":
            return convertOpenApiToolDefinition(source);
        case "azure_function":
            return convertAzureFunctionToolDefinition(source);
        default:
            throw new Error(`Unknown tool type: ${source.type}`);
    }
}
function convertCodeInterpreterToolDefinition(source) {
    return {
        type: source.type,
    };
}
function convertFileSearchToolDefinition(source) {
    return Object.assign({ type: source.type }, (source.fileSearch && {
        file_search: convertFileSearchToolDefinitionDetails(source.fileSearch),
    }));
}
function convertFunctionToolDefinition(source) {
    return {
        type: source.type,
        function: convertFunctionDefinition(source.function),
    };
}
function convertBingGroundingToolDefinition(source) {
    return {
        type: source.type,
        bing_grounding: convertToolConnectionList(source.bingGrounding),
    };
}
function convertMicrosoftFabricToolDefinition(source) {
    return {
        type: source.type,
        fabric_dataagent: convertToolConnectionList(source.fabricDataAgent),
    };
}
function convertSharepointToolDefinition(source) {
    return {
        type: source.type,
        sharepoint_grounding: convertToolConnectionList(source.sharepointGrounding),
    };
}
function convertAzureAISearchToolDefinition(source) {
    return {
        type: source.type,
    };
}
function convertOpenApiToolDefinition(source) {
    return {
        type: source.type,
        openapi: source.openapi,
    };
}
function convertFileSearchToolDefinitionDetails(source) {
    return Object.assign(Object.assign({}, (source.maxNumResults && { max_num_results: source.maxNumResults })), (source.rankingOptions && {
        ranking_options: convertFileSearchRankingOptions(source.rankingOptions),
    }));
}
function convertFileSearchRankingOptions(source) {
    return {
        ranker: source.ranker,
        score_threshold: source.scoreThreshold,
    };
}
function convertCodeInterpreterToolResource(source) {
    return Object.assign({ file_ids: source.fileIds }, (source.dataSources && {
        data_sources: source.dataSources.map(convertVectorStoreDataSource),
    }));
}
export function convertVectorStoreDataSource(source) {
    return {
        uri: source.uri,
        type: source.type,
    };
}
function convertFileSearchToolResource(source) {
    return Object.assign(Object.assign({}, (source.vectorStoreIds && { vector_store_ids: source.vectorStoreIds })), (source.vectorStores && {
        vector_stores: source.vectorStores.map(convertVectorStoreConfigurations),
    }));
}
function convertAzureFunctionToolDefinition(source) {
    return {
        type: source.type,
        azure_function: convertAzureFunctionDefinition(source.azureFunction),
    };
}
function convertAzureFunctionDefinition(source) {
    return {
        function: source.function,
        input_binding: {
            type: source.inputBinding.type,
            storage_queue: {
                queue_service_endpoint: source.inputBinding.storageQueue.queueServiceEndpoint,
                queue_name: source.inputBinding.storageQueue.queueName,
            },
        },
        output_binding: {
            type: source.outputBinding.type,
            storage_queue: {
                queue_service_endpoint: source.outputBinding.storageQueue.queueServiceEndpoint,
                queue_name: source.outputBinding.storageQueue.queueName,
            },
        },
    };
}
function convertVectorStoreConfigurations(source) {
    return {
        name: source.name,
        configuration: convertVectorStoreConfiguration(source.configuration),
    };
}
function convertVectorStoreConfiguration(source) {
    return {
        data_sources: source.dataSources.map(convertVectorStoreDataSource),
    };
}
function convertAzureAISearchResource(source) {
    return Object.assign({}, (source.indexes && { indexes: source.indexes.map(convertIndexResource) }));
}
function convertIndexResource(source) {
    return {
        index_connection_id: source.indexConnectionId,
        index_name: source.indexName,
    };
}
export function convertUpdateAgentOptions(source) {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (source.model && { model: source.model })), (source.name && { name: source.name })), (source.description && { description: source.description })), (source.instructions && { instructions: source.instructions })), (source.tools && { tools: source.tools.map(convertToolDefinition) })), (source.toolResources && { tool_resources: convertToolResources(source.toolResources) })), (source.temperature !== undefined && { temperature: source.temperature })), (source.topP !== undefined && { top_p: source.topP })), (source.responseFormat && { response_format: source.responseFormat })), (source.metadata && { metadata: source.metadata }));
}
export function convertAgentThreadCreationOptions(source) {
    return Object.assign(Object.assign(Object.assign({}, (source.messages && { messages: source.messages.map(convertThreadMessageOptions) })), (source.toolResources && { tool_resources: convertToolResources(source.toolResources) })), (source.metadata && { metadata: source.metadata }));
}
export function convertAgentThreadUpdateOptions(source) {
    return Object.assign(Object.assign({}, (source.toolResources && { tool_resources: convertToolResources(source.toolResources) })), (source.metadata && { metadata: source.metadata }));
}
function convertThreadMessageOptions(source) {
    return Object.assign(Object.assign({ role: source.role, content: source.content }, (source.attachments && { attachments: source.attachments.map(convertMessageAttachment) })), (source.metadata && { metadata: source.metadata }));
}
function convertMessageAttachment(source) {
    return Object.assign(Object.assign({ file_id: source.fileId }, (source.dataSource && {
        data_source: convertVectorStoreDataSource(source.dataSource),
    })), (source.tools && { tools: source.tools.map(convertMessageAttachmentToolDefinition) }));
}
export function convertCreateRunOptions(source) {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ assistant_id: source.assistantId }, (source.model && { model: source.model })), (source.instructions && { instructions: source.instructions })), (source.additionalInstructions && {
        additional_instructions: source.additionalInstructions,
    })), (source.additionalMessages && {
        additional_messages: source.additionalMessages.map(convertThreadMessageOptions),
    })), (source.tools && { tools: source.tools.map(convertToolDefinition) })), (source.stream !== undefined && { stream: source.stream })), (source.temperature !== undefined && { temperature: source.temperature })), (source.topP !== undefined && { top_p: source.topP })), (source.maxPromptTokens !== undefined && { max_prompt_tokens: source.maxPromptTokens })), (source.maxCompletionTokens !== undefined && {
        max_completion_tokens: source.maxCompletionTokens,
    })), (source.truncationStrategy && {
        truncation_strategy: convertTruncationObject(source.truncationStrategy),
    })), (source.toolChoice && { tool_choice: source.toolChoice })), (source.responseFormat && { response_format: source.responseFormat })), (source.metadata && { metadata: source.metadata }));
}
function convertTruncationObject(source) {
    return Object.assign({ type: source.type }, (source.lastMessages !== undefined && { last_messages: source.lastMessages }));
}
function convertUpdateToolResourcesOptions(source) {
    return Object.assign(Object.assign(Object.assign({}, (source.codeInterpreter && {
        code_interpreter: convertUpdateCodeInterpreterToolResourceOptions(source.codeInterpreter),
    })), (source.fileSearch && {
        file_search: convertUpdateFileSearchToolResourceOptions(source.fileSearch),
    })), (source.azureAISearch && {
        azure_ai_search: convertAzureAISearchResource(source.azureAISearch),
    }));
}
function convertUpdateCodeInterpreterToolResourceOptions(source) {
    return Object.assign({}, (source.fileIds && { file_ids: source.fileIds }));
}
function convertUpdateFileSearchToolResourceOptions(source) {
    return Object.assign({}, (source.vectorStoreIds && { vector_store_ids: source.vectorStoreIds }));
}
export function convertToolOutput(source) {
    return Object.assign(Object.assign({}, (source.toolCallId !== undefined && { tool_call_id: source.toolCallId })), (source.output !== undefined && { output: source.output }));
}
export function convertCreateAndRunThreadOptions(source) {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ assistant_id: source.assistantId }, (source.thread && { thread: convertAgentThreadCreationOptions(source.thread) })), (source.model && { model: source.model })), (source.instructions && { instructions: source.instructions })), (source.tools && { tools: source.tools.map(convertToolDefinition) })), (source.toolResources && {
        tool_resources: convertUpdateToolResourcesOptions(source.toolResources),
    })), (source.stream !== undefined && { stream: source.stream })), (source.temperature !== undefined && { temperature: source.temperature })), (source.topP !== undefined && { top_p: source.topP })), (source.maxPromptTokens !== undefined && { max_prompt_tokens: source.maxPromptTokens })), (source.maxCompletionTokens !== undefined && {
        max_completion_tokens: source.maxCompletionTokens,
    })), (source.truncationStrategy && {
        truncation_strategy: convertTruncationObject(source.truncationStrategy),
    })), (source.toolChoice && { tool_choice: source.toolChoice })), (source.responseFormat && { response_format: source.responseFormat })), (source.metadata && { metadata: source.metadata }));
}
function convertVectorStoreExpirationPolicy(source) {
    return {
        anchor: source.anchor,
        days: source.days,
    };
}
export function convertVectorStoreOptions(source) {
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, (source.fileIds && { file_ids: source.fileIds })), (source.name && { name: source.name })), (source.configuration && {
        configuration: convertVectorStoreConfiguration(source.configuration),
    })), (source.expiresAfter && {
        expires_after: convertVectorStoreExpirationPolicy(source.expiresAfter),
    })), (source.chunkingStrategy && {
        chunking_strategy: convertVectorStoreChunkingStrategyRequest(source.chunkingStrategy),
    })), (source.metadata && { metadata: source.metadata }));
}
export function convertVectorStoreChunkingStrategyRequest(source) {
    switch (source.type) {
        case "auto":
            return source;
        case "static":
            return convertVectorStoreStaticChunkingStrategyRequest(source);
        default:
            throw new Error(`Unknown chunking strategy type: ${source.type}`);
    }
}
function convertVectorStoreStaticChunkingStrategyRequest(source) {
    return Object.assign(Object.assign({}, source), { static: convertVectorStoreStaticChunkingStrategyOptions(source.static) });
}
function convertVectorStoreStaticChunkingStrategyOptions(source) {
    return {
        max_chunk_size_tokens: source.maxChunkSizeTokens,
        chunk_overlap_tokens: source.chunkOverlapTokens,
    };
}
export function convertVectorStoreUpdateOptions(source) {
    return Object.assign(Object.assign(Object.assign({}, (source.name && { name: source.name })), (source.expiresAfter && {
        expires_after: convertVectorStoreExpirationPolicy(source.expiresAfter),
    })), (source.metadata && { metadata: source.metadata }));
}
function convertFunctionDefinition(source) {
    return Object.assign(Object.assign({ name: source.name }, (source.description && { description: source.description })), { parameters: source.parameters });
}
function convertToolConnectionList(source) {
    return Object.assign({}, (source.connections && { connections: source.connections.map(convertToolConnection) }));
}
function convertToolConnection(source) {
    return {
        connection_id: source.connectionId,
    };
}
//# sourceMappingURL=convertModelsToWrite.js.map