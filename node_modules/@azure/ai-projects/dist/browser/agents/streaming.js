// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
import { __asyncGenerator, __asyncValues, __await } from "tslib";
import { MessageStreamEvent, RunStepStreamEvent, RunStreamEvent, ThreadStreamEvent, } from "./streamingModels.js";
import { createSseStream } from "@azure/core-sse";
import { isNodeLike } from "@azure/core-util";
import { validateMessages, validateMetadata, validateRunId, validateThreadId, validateToolResources, validateTools, validateTruncationStrategy, } from "./inputValidations.js";
import { createOpenAIError } from "./openAIError.js";
import { convertAgentThreadOutput, convertMessageDeltaChunkOutput, convertRunStepDeltaChunk, convertRunStepOutput, convertThreadMessageOutput, convertThreadRunOutput, } from "../customization/convertOutputModelsFromWire.js";
import { logger } from "../logger.js";
const expectedStatuses = ["200"];
const handlers = [
    { events: Object.values(ThreadStreamEvent), converter: convertAgentThreadOutput },
    { events: Object.values(RunStreamEvent), converter: convertThreadRunOutput },
    { events: Object.values(RunStepStreamEvent), converter: convertRunStepOutput },
    { events: Object.values(MessageStreamEvent), converter: convertThreadMessageOutput },
];
function createAgentStream(stream) {
    const asyncIterator = toAsyncIterable(stream);
    const asyncDisposable = stream;
    return Object.assign(asyncIterator, asyncDisposable);
}
function toAsyncIterable(stream) {
    return __asyncGenerator(this, arguments, function* toAsyncIterable_1() {
        var _a, e_1, _b, _c;
        try {
            for (var _d = true, stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield __await(stream_1.next()), _a = stream_1_1.done, !_a; _d = true) {
                _c = stream_1_1.value;
                _d = false;
                const event = _c;
                const data = deserializeEventData(event);
                yield yield __await({ data: data, event: event.event });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (!_d && !_a && (_b = stream_1.return)) yield __await(_b.call(stream_1));
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
function deserializeEventData(event) {
    try {
        const jsonData = JSON.parse(event.data);
        switch (event.event) {
            case MessageStreamEvent.ThreadMessageDelta:
                return convertMessageDeltaChunkOutput(jsonData);
            case RunStepStreamEvent.ThreadRunStepDelta:
                return convertRunStepDeltaChunk(jsonData);
            default: {
                for (const { events, converter } of handlers) {
                    if (events.includes(event.event)) {
                        return converter(jsonData);
                    }
                }
                return jsonData;
            }
        }
    }
    catch (ex) {
        logger.error(`Failed to parse event data  ${event.event} - error: ${ex}`);
        return event.data;
    }
}
async function processStream(streamResponse) {
    const result = isNodeLike
        ? await streamResponse.asNodeStream()
        : await streamResponse.asBrowserStream();
    if (!expectedStatuses.includes(result.status)) {
        throw createOpenAIError(result);
    }
    if (!result.body) {
        throw new Error("No body in response");
    }
    const stream = isNodeLike
        ? createSseStream(result.body)
        : createSseStream(result.body);
    return createAgentStream(stream);
}
/** Create a run and stream the events */
export async function createRunStreaming(context, threadId, options) {
    validateThreadId(threadId);
    validateCreateThreadAndRunBodyParam(options);
    options.body.stream = true;
    return processStream(context.path("/threads/{threadId}/runs", threadId).post(options));
}
/** Create a thread and run and stream the events */
export async function createThreadAndRunStreaming(context, options) {
    validateCreateThreadAndRunBodyParam(options);
    options.body.stream = true;
    return processStream(context.path("/threads/runs").post(options));
}
export async function submitToolOutputsToRunStreaming(context, threadId, runId, options) {
    validateThreadId(threadId);
    validateRunId(runId);
    options.body.stream = true;
    return processStream(context
        .path("/threads/{threadId}/runs/{runId}/submit_tool_outputs", threadId, runId)
        .post(options));
}
function validateCreateThreadAndRunBodyParam(options) {
    var _a, _b, _c;
    if ("additional_messages" in options.body && options.body.additional_messages) {
        options.body.additional_messages.forEach((message) => validateMessages(message.role));
    }
    if ("thread" in options.body && ((_a = options.body.thread) === null || _a === void 0 ? void 0 : _a.messages)) {
        (_b = options.body.thread) === null || _b === void 0 ? void 0 : _b.messages.forEach((message) => validateMessages(message.role));
    }
    if (options.body.tools) {
        validateTools(options.body.tools);
    }
    if ("tool_resources" in options.body && (options === null || options === void 0 ? void 0 : options.body.tool_resources)) {
        validateToolResources(options.body.tool_resources);
    }
    if (options.body.temperature && (options.body.temperature < 0 || options.body.temperature > 2)) {
        throw new Error("Temperature must be between 0 and 2");
    }
    if (options.body.tool_choice && typeof options.body.tool_choice !== "string") {
        validateTools([options.body.tool_choice]);
    }
    if ((_c = options.body.truncation_strategy) === null || _c === void 0 ? void 0 : _c.type) {
        validateTruncationStrategy(options.body.truncation_strategy.type);
    }
    if (options.body.response_format) {
        if (!["json", "text"].includes(options.body.response_format)) {
            throw new Error("Response format must be either 'json' or 'text'");
        }
    }
    if (options === null || options === void 0 ? void 0 : options.body.metadata) {
        validateMetadata(options.body.metadata);
    }
}
//# sourceMappingURL=streaming.js.map